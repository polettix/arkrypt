#!/usr/bin/env perl
use 5.024;
use warnings;
use Pod::Usage;
use Getopt::Long
  qw< GetOptionsFromArray :config gnu_getopt require_order >;
use experimental qw< postderef signatures >;
no warnings qw< experimental::postderef experimental::signatures >;
use Ouch;
use Data::Dumper;
use IPC::Run;
use Path::Tiny;
use Try::Catch;
use Digest::MD5 qw< md5_hex >;

use constant PREFIX => 'akt-';
use constant LISTFILE => PREFIX . 'list';
use constant SUFFIX_DATA => '.data';
use constant SUFFIX_NAME => '.name';
use constant SUFFIX_PLAIN => '.plain';

main(@ARGV);

sub handle_for ($value, $mode) {
   return (IO::File->new($mode, $value, ':raw'), 1) if defined $value;
   return (IO::Handle->new, 0);
}

sub run_or_die ($command, $in = undef, $out_ref = undef, $err_ref = undef) {
   my ($out, $err);
   $err = 'see above' if $err_ref;
   IPC::Run::run($command, \$in, $out_ref // \$out, $err_ref // \$err)
      or ouch 500, "error running gpg ($?: $err)";
   return unless defined wantarray;
   return $out unless wantarray;
   return ($out, $err);
}

sub encrypt_string_ascii (%args) {
   run_or_die(
      [
         qw< gpg -a --trust-model always -o >, $args{output},
         map({; '-r' => $_ } $args{recipient}->@*),
         '--encrypt', '-',
      ],
      $args{input}
   );
}

sub encrypt_file_binary (%args) {
   my $output = $args{output}->stringify;
   my $tmp = $output . '.tmp';
   run_or_die(
      [
         qw< gpg --trust-model always -o >, $tmp,
         map({; '-r' => $_ } $args{recipient}->@*),
         '--encrypt', $args{input},
      ]
   );
   rename $tmp, $output;
}

sub squash (@pairs) {
   my %flag;
   return reverse grep { !$flag{$_->[0]}++ } reverse @pairs;
}

sub add_to_list ($args, @pairs) {
   @pairs = squash(@pairs);
   my $mapping = join '', map { join(' ', $_->@*) . "\n" } @pairs;

   if ($args->{squash}) {
      my $current = load_list() // '';
      unshift @pairs, split_list($current) if length $current;
      @pairs = squash(@pairs);
      $mapping = join '', map { join(' ', $_->@*) . "\n" } @pairs;
   }

   my $enc_mapping = encrypt_string_ascii(
      recipient => $args->{recipient},
      input => $mapping,
      output => '-',
   );

   my $listfile = path(LISTFILE);
   my $contents = $listfile->exists && ! $args->{squash}
      ? $listfile->slurp_raw : '';
   $listfile->spew_raw($contents . $enc_mapping);

   return $mapping;
}

sub command_decrypt ($cfg, $opts) {
   my ($command_config, $rest) = get_config(decrypt => $opts);
   my %config = ($cfg->%*, $command_config->%*);

   ouch 400, "no input file" unless scalar $rest->@*;

   for my $input ($rest->@*) {
      my $digest = $input =~ s{\..*}{}rmxs;

      my $input_datafile = path($digest . SUFFIX_DATA);
      ouch 400, "input file $input_datafile does not exist"
         unless $input_datafile->exists;

      my $output_filename = path($config{digest_name}
         ? $digest . SUFFIX_PLAIN : filename_for($digest));
      $output_filename->remove
         if $output_filename->exists && $config{force};
      ouch 400, "output filename $output_filename exists"
         if $output_filename->exists;

      run_or_die(
         [ qw< gpg -o >, $output_filename, '--decrypt', $input_datafile ]);
      say {*STDOUT} $output_filename;
   }
}

sub load_list {
   return unless -e LISTFILE;
   run_or_die(
      [ qw< gpg -o - --allow-multiple-messages --decrypt >, LISTFILE ]);
}

sub split_list ($current) {
   map { [ split m{[ ]}mxs, $_, 2 ] }
      grep { length } split m{\n}mxs, $current;
}

sub command_list ($config, $opts) {
   defined(my $list = load_list()) or return;
   print $list;
}

sub filename_for ($name) {
   $name =~ s{\..*}{}mxs;
   my $file_name = path($name . SUFFIX_NAME);
   my $retval;
   if ($file_name->exists) {
      $retval = run_or_die([ qw< gpg -o - --decrypt >, $file_name ]);
      chomp($retval);
   }
   elsif (defined(my $list = load_list())) {
      for my $pair (split_list($list)) {
         next unless $pair->[0] eq $name;
         $retval = $pair->[1];
      }
   }
   if (! defined($retval)) {
      $retval = $name . SUFFIX_PLAIN;
      say {*STDERR} "no filename, using default $retval";
   }
   return $retval;
}

sub command_filename ($config, $opts) {
   ouch 400, 'no input filename' unless scalar $opts->@*;
   my $print_digest = $opts->@* > 1;
   for my $name ($opts->@*) {
      my $filename = filename_for($name);
      print {*STDOUT} "$name " if $print_digest;
      say {*STDOUT} $filename;
   }
}

sub command_regen ($cfg, $opts) {
   my ($command_config, $rest) = get_config(encrypt => $opts);
   my %config = ($cfg->%*, $command_config->%*);

   my $name_rx = join ' ',
      '(?mxs:',
      quotemeta(PREFIX),
      '.*',
      quotemeta(SUFFIX_NAME),
      ')';
   my @pairs;
   for my $file (path('.')->children) {
      next unless $file->is_file;
      next unless $file =~ m{$name_rx};
      my $digest = $file =~ s{\..*}{}rmxs;
      my $filename = filename_for($file);
      push @pairs, [$digest, $filename];
   }

   path(LISTFILE)->remove;
   my $list = add_to_list(\%config, @pairs);
   print $list unless $config{quiet};

   return 0;
}

sub command_squash ($cfg, $opts) {
   my ($command_config, $rest) = get_config(encrypt => $opts);
   my %config = ($cfg->%*, $command_config->%*);
   defined(my $current = load_list()) or return 0;
   path(LISTFILE)->remove;
   my $list = add_to_list(\%config, squash(split_list($current)));
   print $list unless $config{quiet};
   return 0;
}

sub command_encrypt ($cfg, $opts) {
   my ($command_config, $rest) = get_config(encrypt => $opts);
   my %config = ($cfg->%*, $command_config->%*);

   ouch 400, "no input file" unless scalar $rest->@*;

   my (@generated, @pairs);
   try {
      for my $input ($rest->@*) {
         ouch 400, "invalid empty input file" unless length $input;
         $input = path($input);
         ouch 400, "invalid input file $input" unless $input->is_file;

         my $encrypted_filename = encrypt_string_ascii(
            recipient => $config{recipient},
            input  => "$input\n",
            output => '-',
         );
         my $digest = PREFIX . md5_hex($encrypted_filename);

         my $output_data = path($digest . SUFFIX_DATA);
         if ($output_data->exists) {
            ouch 400, "target $output_data already exists"
               unless $config{force};
            $output_data->remove;
         }
         my $output_name = path($digest . SUFFIX_NAME);
         push @generated, [$output_name, $output_data];

         $output_name->spew_raw($encrypted_filename);
         encrypt_file_binary(
            recipient => $config{recipient},
            input => $input,
            output => $output_data,
         );

         push @pairs, [$digest, $input->stringify];
      }
   }
   catch {
      my $exception = $_;
      for my $pair (@generated) {
         unlink $_ for $pair->@*
      }
      die $exception; # rethrow
   };

   my $newfiles = add_to_list(\%config, @pairs);
   print $newfiles unless $config{quiet};

   return 0;
};

sub s3ls ($s3base) { run_or_die([qw< aws s3 ls >, $s3base]) }

sub command_pull ($cfg, $opts) {
   my ($command_config, $rest) = get_config(pull => $opts);
   my %config = ($cfg->%*, $command_config->%*);

   ouch 400, 'no s3base available for pulling files'
      unless length($config{s3base} // '');
   my $s3base = $config{s3base} =~ s{/*\z}{/}rmxs; # ensure one trailing /

   my @queue = $rest->@*;
   ouch 400, "no input file" unless scalar @queue;

   my %available;
   my $list = s3ls($s3base);
   for my $line (split m{\n}mxs, $list) {
      next if $line =~ m{\A \s* PRE \s}mxs; # skip prefixes
      my (undef, undef, undef, $name) = split m{\s+}, $line, 4;
      $available{$name} = 1;
   }

   while (@queue) {
      my $input = shift @queue;
      if (!$available{$input}) {
         my $digest = $input =~ s{\..*}{}rmxs;
         my $pushed = 0;
         for my $suffix (SUFFIX_DATA, SUFFIX_NAME) {
            my $candidate = $digest . $suffix;
            next unless $available{$candidate};
            unshift @queue, $candidate;
            ++$pushed;
         }
         ouch 400, "inexistent file $input" unless $pushed;
         $input = shift @queue;
      }
      ouch 400, "file $input exists locally"
         if -e $input && !$config{force};
      run_or_die([qw< aws s3 cp >, "$s3base$input", '.'], undef, \*STDERR);
      say {*STDOUT} $input;
   }
   return 0;
}

sub command_s3ls ($cfg, $opts) {
   my ($command_config, $rest) = get_config(s3ls => $opts);
   my %config = ($cfg->%*, $command_config->%*);

   ouch 400, 'no s3base available for pulling files'
      unless length($config{s3base} // '');
   my $s3base = $config{s3base} =~ s{/*\z}{/}rmxs; # ensure one trailing /

   print {*STDOUT} s3ls($s3base);
}

sub command_push ($cfg, $opts) {
   my ($command_config, $rest) = get_config(push => $opts);
   my %config = ($cfg->%*, $command_config->%*);

   ouch 400, 'no s3base available for pushing files'
      unless length($config{s3base} // '');
   my $s3base = $config{s3base} =~ s{/*\z}{/}rmxs; # ensure one trailing /

   my @queue = $rest->@*;
   ouch 400, "no input file" unless scalar @queue;

   while (@queue) {
      my $input = shift @queue;
      if (! -e $input) {
         my $digest = $input =~ s{\..*}{}rmxs;
         my $pushed = 0;
         for my $suffix (SUFFIX_DATA, SUFFIX_NAME) {
            my $candidate = $digest . $suffix;
            next unless -e $candidate;
            unshift @queue, $candidate;
            ++$pushed;
         }
         ouch 400, "inexistent file $input" unless $pushed;
         $input = shift @queue;
      }
      run_or_die([qw< aws s3 cp >, $input, $s3base], undef, \*STDERR);
      say {*STDOUT} $input;
   }
   return 0;
}

sub main (@args) {
   my ($config, $rest) = get_config('' => \@args);

   my $command = shift($rest->@*) // '';
   ouch 400, 'no command provided' unless length $command;
   my $real_command = normal_command_name($command);
   my $command_sub = __PACKAGE__->can("command_$real_command")
      or ouch 400, "unknown command $command";
   return $command_sub->($config, $rest);
}

sub normal_command_name ($name) {
   state $main_command_for = {
      expand_aliases(
         decrypt  => [qw< d dec >],
         encrypt  => [qw< e enc >],
         filename => [qw< f name >],
         list     => [qw< l ls >],
         pull     => [qw< p get >],
         push     => [qw< P put >],
         regen    => [qw< r regen-list >],
         squash   => [qw< s squash-list >],
         s3ls     => [qw< rls >],
      )
   };
   return $main_command_for->{$name} // undef;
}

sub get_config($command, $args) {
   state $spec_for = {
      armor => {
         spec => 'armor|a!',
         default => $ENV{ARKRYPT_ARMOR},
      },
      digest_name => {
         spec => 'digest_name|digest-name|D!',
         default => $ENV{ARKRYPT_DIGEST_NAME},
      },
      force => {
         spec => 'force|f!',
         default => $ENV{ARKRYPT_FORCE},
      },
      quiet => {
         spec => 'quiet|q!',
         default => $ENV{ARKRYPT_QUIET},
      },
      s3base => {
         spec => 's3base|s3-base|b=s',
         default => $ENV{ARKRYPT_S3BASE},
      },
      recipient => {
         spec => 'recipient|r=s@',
         default => [
            defined($ENV{ARKRYPT_RECIPIENT})
            ? split m{,}mxs, $ENV{ARKRYPT_RECIPIENT}
            : ()
         ],
      },
      squash => {
         spec => 'squash|s!',
         default => $ENV{ARKRYPT_SQUASH},
      },
   };
   state $options_for = {
      '' => [
         qw< --help --version --man --usage >,
      ],
      decrypt => [
         $spec_for->@{qw< digest_name force >},
      ],
      encrypt => [
         $spec_for->@{qw< armor force quiet recipient squash >},
      ],
      pull => [ $spec_for->@{qw< force quiet s3base >}, ],
      push => [ $spec_for->@{qw< quiet s3base >}, ],
      regen => [ $spec_for->@{qw< quiet recipient >}, ],
      squash => [ $spec_for->@{qw< quiet recipient >}, ],
      s3ls => [ $spec_for->@{qw< s3base >}, ],
   };

   my %default_for;
   my @options = map {
      if (! ref $_) { $_ }
      else {
         my $spec = $_->{spec};
         my $name = $spec =~ s{\|.*}{}rmxs;
         $default_for{$name} = $_->{default} if exists $_->{default};
         $spec;
      }
   } $options_for->{$command}->@*;
   my %config;
   GetOptionsFromArray($args, \%config, @options);
   return({%default_for, %config}, $args);
}

sub expand_aliases (%aliases) {
   return map {
      my $main = $_;
      map { $_ => $main } ($main, $aliases{$main}->@*);
   } keys %aliases;
}

exit 0;
__END__
my $gpg = GnuPG::Interface->new;
$gpg->options->hash_init(armor => 1, quiet => 1);
my $gpg_in  = IO::Handle->new;
my $gpg_out = IO::Handle->new;
my $hds = GnuPG::Handles->new(stdin => $gpg_in, stdout => $gpg_out);

$gpg->options->push_recipients('pass@polettix.it');
my $pid = $gpg->decrypt(handles => $hds);

$gpg_in->print($_) while <>;
$gpg_in->close;

print {*STDOUT} $gpg_out->getlines;
$gpg_out->close;

my $exit_pid = wait;
say {*STDERR} "pid<$pid> exitpid<$exit_pid>";


exit 0;
